@startuml


namespace libwint {

    class Basis {
        __ public data __
            + Molecule& molecule
        __ public methods __
            + void compute_integrals()
    }


    class global {
        Eigen::MatrixXd transform_AO_to_SO(Eigen::MatrixXd& f_AO, Eigen::MatrixXd& C)
    }

}


namespace hf {
    namespace rhf {

        class RHF {
            == constructors ==
                RHF(libwint::Basis &basis, double threshold)
            __ public data __
                + libwint::Basis &basis
                + double threshold
                + const size_t MAX_NO_ITERATIONS = 128
                + Eigen::VectorXd orbital_energies
                + Eigen::MatrixXd C_canonical
                + double energy
        }

        class global {
            .. RHF_functions ..
                size_t HOMO_index(size_t K, size_t N)
                size_t LUMO_index(size_t K, size_t N)
                Eigen::MatrixXd calculate_P(Eigen::MatrixXd &C, size_t N)
                Eigen::MatrixXd calculate_G(Eigen::MatrixXd &P, Eigen::Tensor<double, 4> &tei)
                double calculate_electronic_energy(Eigen::MatrixXd &P, Eigen::MatrixXd &H_core, Eigen::MatrixXd &F)
            .. utility ..
                bool are_equal_eigenvalues(Eigen::VectorXd evals1, Eigen::VectorXd evals2, double tol)
                bool are_equal_eigenvectors(Eigen::VectorXd evec1, Eigen::VectorXd evec2, double tol)
                bool are_equal_sets_eigenvectors(Eigen::MatrixXd evecs1, Eigen::MatrixXd evecs2, double tol)
        }

    }
}



hf.rhf.RHF o--> libwint.Basis

hf.rhf.RHF ..> libwint.global

@enduml