@startuml


namespace libwint {

    class AOBasis {
        __ public methods __
            + libwint::Molecule& **get_molecule**() const
            + void **calculateIntegrals**()
    }


    class IntegralTransformations {
        __ public methods __
            + {static} Eigen::MatrixXd **AO_to_SO**(Eigen::MatrixXd& f_AO, Eigen::MatrixXd& C)
    }

}


namespace hf {
    namespace rhf {

        class RHF {
            __ private members __
                - libwint::Basis& basis
                - double threshold
                - const size_t MAX_NO_SCF_ITERATIONS = 128
                - Eigen::VectorXd& orbital_energies
                - Eigen::MatrixXd& C_canonical
                - double electronic_energy
            __ private methods __
                - Eigen::MatrixXd **calculateP**(Eigen::MatrixXd& C, size_t N)
                - Eigen::MatrixXd **calculateG**(Eigen::MatrixXd& P, Eigen::Tensor<double, 4>& tei)
            == constructors ==
                RHF(libwint::Basis& basis, double scf_threshold)
            __ public methods __
                + Eigen::VectorXd& **get_orbital_energies**() const
                + Eigen::MatrixXd& **get_C_canonical**() const
                + double **get_electronic_energy**() const

                + size_t **HOMOIndex**(size_t K, size_t N)
                + size_t **LUMOIndex**(size_t K, size_t N)
                + double **calculateElectronicEnergy**(Eigen::MatrixXd& P, Eigen::MatrixXd& H_core, Eigen::MatrixXd& F)
        }
    }
}



hf.rhf.RHF o--> libwint.AOBasis

hf.rhf.RHF ..> libwint.IntegralTransformations

@enduml
