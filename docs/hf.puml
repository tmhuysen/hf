@startuml


namespace libwint {

    class AOBasis {
        __ public methods __
            + libwint::Molecule& **get_molecule**() const
    }


    class transformations {
        + {static} Eigen::MatrixXd **transform_AO_to_SO**(Eigen::MatrixXd& f_AO, Eigen::MatrixXd& C)
    }

}


namespace hf {
    namespace rhf {

        class RHF {
            __ private members __
                - const size_t {static} MAX_NUMBER_OF_SCF_CYCLES = 128
                - const double scf_threshold
                - const libwint::AOBasis& ao_basis
                - const size_t N

                - Eigen::VectorXd orbital_energies
                - Eigen::MatrixXd C_canonical
                - double electronic_energy
            __ private methods __
                - Eigen::MatrixXd **calculateP**(const Eigen::MatrixXd& C) const
                - Eigen::MatrixXd **calculateG**(const Eigen::MatrixXd& P, Eigen::Tensor<double, 4>& tei) const
                - double **calculateElectronicEnergy**(const Eigen::MatrixXd& P, const Eigen::MatrixXd& H_core, const Eigen::MatrixXd& F) const
            == constructors ==
                RHF(libwint::AOBasis& ao_basis, size_t N, double scf_threshold)
            __ public methods __
                + Eigen::VectorXd **get_orbital_energies**() const
                + Eigen::MatrixXd **get_C_canonical**() const
                + double **get_electronic_energy**() const

                + void **solve**()

                + {static} size_t **HOMOIndex**(size_t K, size_t N)
                + {static} size_t **LUMOIndex**(size_t K, size_t N)
        }
    }
}



hf.rhf.RHF o--> libwint.AOBasis

hf.rhf.RHF ..> libwint.transformations

@enduml
